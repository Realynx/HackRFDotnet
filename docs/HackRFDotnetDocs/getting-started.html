<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Getting Started With HackRf Dotnet | HackrfDotnet </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Getting Started With HackRf Dotnet | HackrfDotnet ">
      
      
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://github.com/Realynx/HackRFDotnet/blob/master/HackRFDotnetDocs/getting-started.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../logo.svg" alt="HackrfDotnet">
            HackrfDotnet
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="getting-started-with-hackrf-dotnet">Getting Started With HackRf Dotnet</h1>

<p>The most basic way we can use HackRfDotnet is by playing an analogue audio stream.<br>
Amplitude modulation - The phase of the audio signal is encoded in the changes of the amplitude on the carrier rf wave.<br>
Frequency modulation - The phase of the audio signal is encoded in the changes of the phase on the carrier rf wave.</p>
<pre><code class="lang-cs">Console.WriteLine(&quot;looking for HackRf Device...&quot;);
var deviceList = _rfDeviceControllerService.FindDevices();

Console.WriteLine($&quot;Found {deviceList.devicecount} HackRf devices... Opening Rx&quot;);
using var rfDevice = _rfDeviceControllerService.ConnectToFirstDevice();

if (rfDevice is null) {
    Console.WriteLine(&quot;Could not connect to Rf Device&quot;);
    return;
}

// Create an immutable read stream from an RF Device.
using var deviceStream = new IQDeviceStream(rfDevice);

// Open the receive channel on the SDR
deviceStream.OpenRx(SampleRate.FromMsps(20));
</code></pre>
<h3 id="to-play-an-fm-stream-you-would-use-the-following-block-of-code">To play an FM stream you would use the following block of code.</h3>
<pre><code class="lang-cs">// Set the frequency tuning on the SDR device.
rfDevice.SetFrequency(Frequency.FromMHz(98.7f), Bandwidth.FromKHz(200));

// Make a SignalStream of type FM
var fmSignalStream = new FmSignalStream(deviceStream, Bandwidth.FromKHz(200), stereo: true);

// Make an AnaloguePlayer and play the FMSignalStream as an audio stream.
var fmPlayer = new AnaloguePlayer(fmSignalStream);
fmPlayer.PlayStreamAsync(rfDevice.Frequency, rfDevice.Bandwidth, SampleRate.FromKsps(48));
</code></pre>
<h3 id="to-play-an-am-stream-you-would-use-the-following-block-of-code">To play an AM stream you would use the following block of code.</h3>
<pre><code class="lang-cs">// Set the frequency tuning on the SDR device.
rfDevice.SetFrequency(Frequency.FromMHz(118.4f), Bandwidth.FromKHz(10));

// Make a SignalStream of type AM
var amSignalStream = new AmSignalStream(deviceStream, Bandwidth.FromKHz(10));

// Make an AnaloguePlayer and play the AMSignalStream as an audio stream.
var amPlayer = new AnaloguePlayer(amSignalStream);
amPlayer.PlayStreamAsync(rfDevice.Frequency, rfDevice.Bandwidth, SampleRate.FromKsps(48));
</code></pre>
<p>FmSignalStream and AmSignalStream, are both encapsulations of a pre-programmed SignalProcessingPipeline.
This processing pipeline downsamples, filters, and converts the tuned frequency in the Inphase &amp; Quadrature
stream into an analogue audio signal. This analogue audio signal is then read by NAudio, and re-sampled to the
configured playback samplerate, which is usually 48Khz.</p>
<h1 id="signal-processing-pipelines">Signal Processing Pipelines</h1>
<p>A Signal Processing Pipeline, is a method of applying a chain of effects onto a signal from the SignalStream.
A SignalStream is created constructed with a SignalProcessingPipeline. The SignalStream will then use this configured SignalProcessingPipeline to convert the signal before calling Read on the SignalStream. Calling Read will returned already processed data.</p>
<p>A SignalStream is a stream piped from the IQDeviceStream, the IQDeviceStream is the root immutable IQ stream.
Without a Signal Processing Pipeline you will get the full capture data as seen from the IQDeviceStream.</p>
<p>The example project creates a Digital Signal Processing work flow similar to the following.
IQDeviceStream maintains a ring buffer with a background worker.
Every SignalStream created from IQDeviceStream, also runs a background task to execute the Signal Processing Pipeline. This background thread ensures the ring bigger in your signal stream always has data to be read.</p>
<p>A Signal processing chain or pipeline may convert or change the format of the data throughout the process. In example, the FMDecoder effect expects an input of IQ samples and makes an output of float samples. Effects have expected inputs and outputs to operate within a signal chain.</p>
<pre><code class="lang-mermaid">flowchart TD

subgraph b[Signal Processing Pipeline]
    ProcessingChain(Signal Processing Chain)
    downsample(IQDownSampleEffect)
    fft(FftEffect)
    lowpass(LowPassFilterEffect)
    inverseFft(FftEffect)
    fmDecoder(FmDecoder)

    ProcessingChain
    --&gt;|IQ| downsample
    --&gt;|IQ 'Reduced SampleRate'| fft
    --&gt;|Time Domain| lowpass
    --&gt;|IQ| inverseFft
    --&gt;|Frequency Domain| fmDecoder
    --&gt; |float| wave(WaveOut)

end

subgraph a[Signal Chain]
    deviceSt(IQDeviceStream)

    signalSignalA(SignalStream)
    signalSignalB(SignalStream)
    fmStream(FmStream)

    visualizer(Spectrum Visual)
    sampleProvider(ISampleProvider)
    waveout(NAudio Playback)

    deviceSt --&gt;|Inphase Quadrature| signalSignalA
    deviceSt --&gt;|Inphase Quadrature| signalSignalB
    signalSignalB --&gt; fmStream

    signalSignalA --&gt; visualizer

    fmStream --&gt; sampleProvider
    sampleProvider --&gt; waveout
end


classDef Color fill:#bf80ff,color:#000;
classDef Transparent fill:none, stroke: none

class a Transparent;
class b Transparent;

class ProcessingChain Color;
class signalSignalA Color;
class signalSignalB Color;
class fmStream Color;
</code></pre>
<h2 id="signal-pipeline-example">Signal Pipeline Example</h2>
<p>The following is an FM Decoder example for a Signal Processing Pipeline.<br>
An FMStream will pre-configure this same processing pipeline before sending data to NAudio as an ISampleProvider.</p>
<pre><code class="lang-cs">// Create a processing pipeline.
var signalPipeline = new SignalProcessingPipeline&lt;IQ&gt;();

signalPipeline
    // Add a root effect, this is used to track the parent effect in the chain.
    .WithRootEffect(new IQDownSampleEffect(deviceStream.SampleRate,
        stationBandwidth.NyquistSampleRate, out reducedRate, out var producedChunkSize))

    // Add remaining effects as Child Effect.
    .AddChildEffect(new FftEffect(true, producedChunkSize))
    .AddChildEffect(new LowPassFilterEffect(reducedRate, stationBandwidth))
    .AddChildEffect(new FftEffect(false, producedChunkSize))
    .AddChildEffect(new FmDecoder());

// You can use a signal processing pipeline by passing in a buffer of data to be processed to the AffectSignal function.
</code></pre>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/Realynx/HackRFDotnet/blob/master/HackRFDotnetDocs/getting-started.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Github <a href="https://github.com/Realynx/HackRFDotnet">HackRfDotnet</a>.</span>
        </div>
      </div>
    </footer>
  </body>
</html>
